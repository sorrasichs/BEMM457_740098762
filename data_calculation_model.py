# -*- coding: utf-8 -*-
"""final_model_code.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vj7UYMJCcGTFvsbXZGFOXjwf63zxuUni
"""

# Business Question 1 - ANOVA Test
# Dataset used: Cleaned JDE 2025 File (JDE_2025_cleanedv2.csv)
# Figure 3, 4, 5, 9
# Code done in Google Colab

import pandas as pd
import numpy as np
import statsmodels.api as sm
from statsmodels.formula.api import ols
import matplotlib.pyplot as plt

df = pd.read_csv("/content/drive/MyDrive/TfL files/CLEANED/JDE_2025_cleanedv2.csv")
df = df.rename(columns={"total_duration_(ms)": "total_duration_ms"})

df = df.dropna(subset=["total_duration_ms", "bike_model", "start_time_of_day"])
df["bike_model"] = df["bike_model"].astype("category")
df["start_time_of_day"] = df["start_time_of_day"].astype("category")

# Two-way ANOVA with interaction
model = ols("total_duration_ms ~ C(start_time_of_day) * C(bike_model)", data=df).fit()
anova_table = sm.stats.anova_lm(model, typ=2)
print(anova_table)

# Visualisation: mean duration (minutes) by time_of_day, split by bike type
plot_df = df.copy()
plot_df["duration_min"] = plot_df["total_duration_ms"] / 60000

# Compute mean and 95% CI
g = plot_df.groupby(["start_time_of_day", "bike_model"])["duration_min"]
summary = g.agg(["mean", "count", "std"]).reset_index()
summary["se"] = summary["std"] / np.sqrt(summary["count"])
summary["ci95"] = 1.96 * summary["se"]

# Order time-of-day
tod_order = ["Morning", "Afternoon", "Evening", "Night"]
summary["start_time_of_day"] = pd.Categorical(summary["start_time_of_day"], categories=tod_order, ordered=True)
summary = summary.sort_values("start_time_of_day")

# Build grouped bars
cats = tod_order
bike_types = ["classic_bike", "e_bike"]

x = np.arange(len(cats))
width = 0.35

means_classic = []
cis_classic = []
means_ebike = []
cis_ebike = []

for c in cats:
    row_c = summary[(summary["start_time_of_day"] == c) & (summary["bike_model"] == "classic_bike")]
    row_e = summary[(summary["start_time_of_day"] == c) & (summary["bike_model"] == "e_bike")]

    means_classic.append(row_c["mean"].iloc[0] if len(row_c) else np.nan)
    cis_classic.append(row_c["ci95"].iloc[0] if len(row_c) else np.nan)

    means_ebike.append(row_e["mean"].iloc[0] if len(row_e) else np.nan)
    cis_ebike.append(row_e["ci95"].iloc[0] if len(row_e) else np.nan)

# bar graph for classic bike only

plt.figure(figsize=(9, 4.5))
plt.bar(x - width/2, means_classic, width, yerr=cis_classic, capsize=4, label="classic_bike", color="tab:blue")

plt.xticks(x, cats)
plt.ylabel("Mean trip duration (minutes)")
plt.title("Trip Duration’s Mean of Classic Bikes by Time of Day  (95% CI)")
plt.legend()
plt.tight_layout()
plt.show()

# bar graph for e-bike only

plt.figure(figsize=(9, 4.5))
plt.bar(x + width/2, means_ebike, width, yerr=cis_ebike, capsize=4, label="e_bike",color="tab:orange")

plt.xticks(x, cats)
plt.ylabel("Mean trip duration (minutes)")
plt.title("Trip Duration’s Mean of E-Bikes by Time of Day  (95% CI)")
plt.legend()
plt.tight_layout()
plt.show()

# bar graph for both

plt.figure(figsize=(9, 4.5))
plt.bar(x - width/2, means_classic, width, yerr=cis_classic, capsize=4, label="classic_bike", color="tab:blue")
plt.bar(x + width/2, means_ebike, width, yerr=cis_ebike, capsize=4, label="e_bike",color="tab:orange")

plt.xticks(x, cats)
plt.ylabel("Mean trip duration (minutes)")
plt.title("Trip Duration’s Mean by Time of Day and Bike Type (95% CI)")
plt.legend()
plt.tight_layout()
plt.show()

# Business Question 2 - SARIMAX Forecast
# Dataset used: Cleaned JDE 2025 File (JDE_2025_cleanedv2.csv)
# Figure 6, 7, 8, 10
# Code done in Google Colab

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

from statsmodels.tsa.statespace.sarimax import SARIMAX
from sklearn.metrics import mean_absolute_error, mean_squared_error

df = pd.read_csv("/content/drive/MyDrive/TfL files/CLEANED/JDE_2025_cleanedv2.csv")

# Use DATE ONLY (replace "start_date" with your date column)
df["date"] = pd.to_datetime(df["start_date"], errors="coerce")
df = df.dropna(subset=["date", "bike_model"])
df["bike_model"] = df["bike_model"].astype(str)

# Aggregate to daily trip counts by bike type
daily_counts = (
    df.groupby(["date", "bike_model"])
      .size()
      .reset_index(name="trip_count")
)

# Full daily index (ensures missing dates filled with 0)
full_idx = pd.date_range(daily_counts["date"].min(), daily_counts["date"].max(), freq="D")


# 1 Build a daily time series per bike type

series_by_bike = {}
for bike in daily_counts["bike_model"].unique():
    s = (daily_counts[daily_counts["bike_model"] == bike]
         .set_index("date")["trip_count"]
         .sort_index())
    s = s.reindex(full_idx, fill_value=0)
    s.index.name = "date"
    series_by_bike[bike] = s



# 2 Visualise historical demand (multiple lines)

plt.figure(figsize=(10, 4))
for bike, s in series_by_bike.items():
    plt.plot(s.index, s.values, label=bike)

plt.title("Daily Bike Demand Over Time (segmented by bike type)")
plt.xlabel("Date")
plt.ylabel("Trips per day")
plt.legend()
plt.tight_layout()
plt.show()



# 3 Fit SARIMAX(ARIMA(1,1,1)) and evaluate

def fit_sarimax_arima(series, order=(1, 1, 1), train_ratio=0.8):
    split = int(len(series) * train_ratio)
    train = series.iloc[:split]
    test = series.iloc[split:]

    # SARIMAX with no seasonal component = ARIMA-like
    model = SARIMAX(
        train,
        order=order,
        seasonal_order=(0, 0, 0, 0),
        enforce_stationarity=False,
        enforce_invertibility=False
    )

    fitted = model.fit(disp=False)

    forecast = fitted.get_forecast(steps=len(test)).predicted_mean
    forecast = pd.Series(forecast, index=test.index)

    mae = mean_absolute_error(test, forecast)
    rmse = np.sqrt(mean_squared_error(test, forecast))

    return train, test, forecast, mae, rmse, fitted


print("\n=== SARIMAX (ARIMA(1,1,1)) Results + Forecast Accuracy (by bike type) ===\n")

plt.figure(figsize=(10, 4))

for bike, s in series_by_bike.items():
    train, test, forecast, mae, rmse, fitted = fit_sarimax_arima(
        s, order=(1, 1, 1), train_ratio=0.8
    )

    # Print SARIMAX results summary
    print(f"\n\n==================== Bike type: {bike} ====================")
    print(fitted.summary())

    # Print accuracy
    print(f"\nMAE  (trips/day): {mae:,.2f}")
    print(f"RMSE (trips/day): {rmse:,.2f}")

    # Plot forecast vs actual for test set
    plt.plot(test.index, test.values, label=f"Actual ({bike})")
    plt.plot(forecast.index, forecast.values, linestyle="--", label=f"Forecast ({bike})")

plt.title("SARIMAX Forecast vs Actual (Daily Bike Demand by Bike Type)")
plt.xlabel("Date")
plt.ylabel("Trips per day")
plt.legend()
plt.tight_layout()
plt.show()


# SARIMAX – Classic bike

classic_series = series_by_bike["classic_bike"]

train_c, test_c, forecast_c, mae_c, rmse_c, fitted_c = fit_sarimax_arima(
    classic_series, order=(1, 1, 1), train_ratio=0.8
)

plt.figure(figsize=(10, 4))

plt.plot(
    test_c.index,
    test_c.values,
    label="Actual (Classic bike)",
    color="tab:blue"
)

plt.plot(
    forecast_c.index,
    forecast_c.values,
    linestyle="--",
    label="Forecast (Classic bike)",
    color="tab:purple"
)

plt.title("SARIMAX Forecast vs Actual (Daily Demand – Classic Bike)")
plt.xlabel("Date")
plt.ylabel("Trips per day")
plt.legend()
plt.tight_layout()
plt.show()


# SARIMAX – E-bike

ebike_series = series_by_bike["e_bike"]

train_e, test_e, forecast_e, mae_e, rmse_e, fitted_e = fit_sarimax_arima(
    ebike_series, order=(1, 1, 1), train_ratio=0.8
)

plt.figure(figsize=(10, 4))

plt.plot(
    test_e.index,
    test_e.values,
    label="Actual (E-bike)",
    color="tab:orange"
)

plt.plot(
    forecast_e.index,
    forecast_e.values,
    linestyle="--",
    label="Forecast (E-bike)",
    color="tab:red"
)

plt.title("SARIMAX Forecast vs Actual (Daily Demand – E-bike)")
plt.xlabel("Date")
plt.ylabel("Trips per day")
plt.legend()
plt.tight_layout()
plt.show()